<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id$ -->
<!--
	~ JBoss, Home of Professional Open Source
	~ Copyright 2010, Red Hat, Inc. and/or its affiliates, and individual contributors
	~ by the @authors tag. See the copyright.txt in the distribution for a
	~ full listing of individual contributors.
	~
	~ Licensed under the Apache License, Version 2.0 (the "License");
	~ you may not use this file except in compliance with the License.
	~ You may obtain a copy of the License at
	~ http://www.apache.org/licenses/LICENSE-2.0
	~ Unless required by applicable law or agreed to in writing, software
	~ distributed under the License is distributed on an "AS IS" BASIS,
	~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	~ See the License for the specific language governing permissions and
	~ limitations under the License.
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY versionNumber "1.0.0">
<!ENTITY copyrightYear "2010">
<!ENTITY copyrightHolder "Red Hat Middleware, LLC.">
]>
<book lang="en">
  <bookinfo>
    <title>Hibernate Metamodel Generator</title>

    <subtitle>JPA 2 Static Metamodel Annotation Processor</subtitle>

    <subtitle>Reference Guide</subtitle>

    <releaseinfo>&versionNumber;</releaseinfo>

    <productnumber>&versionNumber;</productnumber>

    <copyright>
      <year>&copyrightYear;</year>

      <holder>&copyrightHolder;</holder>
    </copyright>
  </bookinfo>

  <toc></toc>

  <chapter id="introduction">
    <title>Introduction</title>

    <section id="whatisit" revision="1">
      <title>What is it about?</title>

      <para>JPA 2 defines a new typesafe <classname>Criteria</classname> API
      which allows criteria queries to be constructed in a strongly-typed
      manner, using metamodel objects to provide type safety. This type saftey
      is of course only useful for developers if the task of the metamodel
      generation can be automated. Hibernate Static Metamodel Generator is an
      annotation processor based on the annotation processing API defined in
      <ulink url="???">JSR 269</ulink> with the task of creating the static
      metamodel classes for JPA 2 entities. The following examples show a
      managed JPA 2 entity, together with is metamodel class and an example
      typesafe query.</para>

      <example id="jpa2-entity-example">
        <title>JPA 2 annotated entity</title>

        <programlisting>@Entity public class Order {
    @Id 
    Integer id;
    @ManyToOne 
    Customer customer;
    @OneToMany 
    Set&lt;Item&gt; items;
    BigDecimal totalCost;
    ...
}
</programlisting>
      </example>

      <example id="metamodel-class-example">
        <title>Matching metamodel class for entity
        <classname>Order</classname></title>

        <programlisting>@StaticMetamodel(Order.class)
public class Order_ {
    public static volatile SingularAttribute&lt;Order, Integer&gt; id;
    public static volatile SingularAttribute&lt;Order, Customer&gt; customer;
    public static volatile SetAttribute&lt;Order, Item&gt; items;
    public static volatile SingularAttribute&lt;Order, BigDecimal&gt; totalCost;
}
</programlisting>
      </example>

      <example id="criteria-example" label="">
        <title>Example of typesafe query using the metamodel class
        <classname>Order_</classname> </title>

        <programlisting>CriteriaBuilder cb = ordersEntityManager.getCriteriaBuilder();
CriteriaQuery&lt;Order&gt; cq = cb.createQuery(Order.class);
SetJoin&lt;Order, Item&gt; itemNode = cq.from(Order.class).join(Order_.orderItems);
cq.where( cb.equal(itemNode.get(Item_.id), 5 ) ).distinct(true);
</programlisting>
      </example>
    </section>

    <section>
      <title>Canonical Metamodel</title>

      <para>The canonical metamodel classes the annotation processor produces
      for every managed class in the persistence unit follow these rules
      defined in the JPA 2 specification:</para>

      <para><itemizedlist>
          <listitem>
            <para>For each managed class X in package p, a metamodel class X_
            in package p is created.</para>
          </listitem>

          <listitem>
            <para>The name of the metamodel class is derived from the name of
            the managed class by appending "_" to the name of the managed
            class.</para>
          </listitem>

          <listitem>
            <para>The metamodel class X_ must be annotated with the
            javax.persistence.Static- Metamodel annotation.</para>
          </listitem>

          <listitem>
            <para>If class X extends another class S, where S is the most
            derived managed class (i.e., entity or mapped superclass) extended
            by X, then class X_ must extend class S_, where S_ is the
            metamodel class created for S.</para>
          </listitem>

          <listitem>
            <para>For every persistent non-collection-valued attribute y
            declared by class X, where the type of y is Y, the metamodel class
            must contain a declaration as follows: <programlisting>public static volatile SingularAttribute&lt;X, Y&gt; y;</programlisting></para>
          </listitem>

          <listitem>
            <para>For every persistent collection-valued attribute z declared
            by class X, where the element type of z is Z, the metamodel class
            must contain a declaration as follows:<itemizedlist>
                <listitem>
                  <para>if the collection type of z is java.util.Collection,
                  then <programlisting>public static volatile CollectionAttribute&lt;X, Z&gt; z;</programlisting></para>
                </listitem>

                <listitem>
                  <para>if the collection type of z is java.util.Set, then
                  <programlisting>public static volatile SetAttribute&lt;X, Z&gt; z;</programlisting></para>
                </listitem>

                <listitem>
                  <para>if the collection type of z is java.util.List, then
                  <programlisting>public static volatile ListAttribute&lt;X, Z&gt; z;</programlisting></para>
                </listitem>

                <listitem>
                  <para>if the collection type of z is java.util.Map, then
                  <programlisting>public static volatile MapAttribute&lt;X, K, Z&gt; z;</programlisting>
                  where K is the type of the key of the map in class X</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist>Import statements must be included for the needed
      <classname>javax.persistence.metamodel</classname> types as appropriate
      and all classes <classname>X</classname>, <classname>Y</classname>,
      <classname>Z</classname>, and <classname>K</classname>.</para>
    </section>
  </chapter>

  <chapter>
    <title>Usage</title>

    <para>In most cases the annotation processor will automatically run
    provided the annotation processor jar is on the classpath. This happens
    due to Java's Service Provider contract and the fact the the Hibernate
    Static Metamodel Generator jar files contains the file
    <classname>javax.annotation.processing.Processor</classname> in the
    <filename>META-INF/services</filename> listing
    <classname>org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor</classname>
    as annotation processor. However, a JDK 6 is a prerequisite. The jar file
    itself can be found in the <ulink url="http://repository.jboss.com/">JBoss
    Maven repository</ulink> under:</para>

    <example id="maven-dependency" label="">
      <title>Maven dependency for Hibernate Static Metamodel Generator</title>

      <programlisting>&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</programlisting>
    </example>

    <section>
      <title>Usage from the command line</title>

      <para><section revision="1">
          <title>Usage with Ant</title>
        </section>As mentioned before, the annotation processor will run
      automatically in a Java 6 environment. In case you want configure the
      processor explicitly or disable it you can use the compilerarg option of
      the Javac Task. The supported command javac line options are listed
      here. <section revision="1">
          <title>Usage with Maven</title>
        </section>There are several ways of running the annotation processor
      as part of a Maven build. It will automatically run if you are using a
      JDK 6 compiler and the annotation processor jar is on the classpath. In
      case you have more than one annotation processors on your classpath you
      can explicitly pass the processor option to the compiler plugin:</para>

      <para><example>
          <title>Maven compiler plugin configuration - direct
          execution</title>

          <programlisting>&lt;plugin&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;source&gt;1.6&lt;/source&gt;
        &lt;target&gt;1.6&lt;/target&gt;
        &lt;compilerArguments&gt;
            &lt;processor&gt;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&lt;/processor&gt;
        &lt;/compilerArguments&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
        </example></para>

      <para>The maven-compiler-plugin approach has the disadvantage that the
      maven compiler plugin does currently not allow to specify multiple
      compiler arguments (MCOMPILER-62) and that messages from the Messenger
      API are suppressed (MCOMPILER-66). A better approach is to disable
      annotation processing for the compiler plugin:</para>

      <example>
        <title>Maven compiler plugin configuration - indirect
        execution</title>

        <programlisting>&lt;plugin&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;source&gt;1.6&lt;/source&gt;
        &lt;target&gt;1.6&lt;/target&gt;
        &lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
      </example>

      <para>and use the maven-annotation-plugin for annotation processing (you
      will need the following additional maven repositories -
      maven-annotation-plugin and jfrog):</para>

      <example>
        <title>Maven compiler plugin configuration with
        maven-annotation-plugin</title>

        <programlisting>&lt;plugin&gt;
    &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt;
    &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;process&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;process&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;configuration&gt;
                &lt;!-- source output directory --&gt;
                &lt;outputDirectory&gt;target/metamodel&lt;/outputDirectory&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.3&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;add-source&lt;/id&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;add-source&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;sources&gt;
                    &lt;source&gt;target/metamodel&lt;/source&gt;
                &lt;/sources&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</programlisting>
      </example>
    </section>

    <section>
      <title>Usage within the IDE</title>

      <para>Of course you also want to have annotation processing available in
      your favorite IDE. The following paragraphs and screenshots show you how
      to enable the Hibernate Static Metamodel Generator within your
      IDE.</para>

      <section>
        <title>Idea</title>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentdepth="" contentwidth="150mm"
                       fileref="idea-annotation-processor-config.png"
                       scalefit="" />
          </imageobject>

          <imageobject role="html">
            <imagedata depth="" fileref="idea-annotation-processor-config.png"
                       scalefit="1" />
          </imageobject>
        </mediaobject>
      </section>

      <section>
        <title>Eclipse</title>

        <para>In Eclipse from the Galileo release onwards exists an additional
        configuration section under Java Compiler where you can configure all
        kinds of aspects of annotation processing. Just check the "Enable
        annotation processing" option, configure the directory for the
        generated sources and finally add the Hibernate Static Metamodel
        Generator and JPA 2 jar files to the factory path.</para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentdepth="" contentwidth="150mm"
                       fileref="eclipse-annotation-processor-config.png"
                       scalefit="" />
          </imageobject>

          <imageobject role="html">
            <imagedata depth=""
                       fileref="eclipse-annotation-processor-config.png"
                       scalefit="1" />
          </imageobject>
        </mediaobject>
      </section>

      <section>
        <title>NetBeans</title>

        <para>TODO</para>
      </section>
    </section>

    <section>
      <title>Options</title>

      <para>The annotaton processor accepts a series of custom properties
      which can be passed to the processor execution in the format
      <literal>-A[property]=[value]</literal>. The supported properties
      are:<table>
          <title>Annotation processor options (passed via
          -A[property]=[value])</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>Option name</entry>

                <entry>Option value and usage</entry>
              </row>

              <row>
                <entry>debug</entry>

                <entry>if set to <literal>true</literal> additional trace
                information will be outputted by the processor</entry>
              </row>

              <row>
                <entry>persistenceXml</entry>

                <entry>Per default the processor looks in
                <filename>/META-INF</filename> for persistence.xml. Specifying
                this option a <filename>persitence.xml</filename> file from a
                different location can be specified (has to be on the
                classpath)</entry>
              </row>

              <row>
                <entry>ormXml</entry>

                <entry>Allows to specify additional entity mapping files. The
                specified value for this option is a comma separated string of
                mapping file names. Even when this option is specified
                <filename>/META-INF/orm.xml</filename> is implicit.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>
  </chapter>
</book>
